#include <ttak/security/security_engine.h>

#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "test_macros.h"

static void test_rfc8439_vector(void) {
    static const uint8_t key[32] = {
        0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,
        0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
        0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,
        0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F
    };
    static const uint8_t nonce[12] = {
        0x07,0x00,0x00,0x00,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47
    };
    static const uint8_t aad[12] = {
        0x50,0x51,0x52,0x53,0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7
    };
    static const uint8_t plaintext[114] = {
        0x4C,0x61,0x64,0x69,0x65,0x73,0x20,0x61,0x6E,0x64,0x20,0x47,
        0x65,0x6E,0x74,0x6C,0x65,0x6D,0x65,0x6E,0x20,0x6F,0x66,0x20,
        0x74,0x68,0x65,0x20,0x63,0x6C,0x61,0x73,0x73,0x20,0x6F,0x66,
        0x20,0x27,0x39,0x39,0x3A,0x20,0x49,0x66,0x20,0x49,0x20,0x63,
        0x6F,0x75,0x6C,0x64,0x20,0x6F,0x66,0x66,0x65,0x72,0x20,0x79,
        0x6F,0x75,0x20,0x6F,0x6E,0x6C,0x79,0x20,0x6F,0x6E,0x65,0x20,
        0x74,0x69,0x70,0x20,0x66,0x6F,0x72,0x20,0x74,0x68,0x65,0x20,
        0x66,0x75,0x74,0x75,0x72,0x65,0x2C,0x20,0x73,0x75,0x6E,0x73,
        0x63,0x72,0x65,0x65,0x6E,0x20,0x77,0x6F,0x75,0x6C,0x64,0x20,
        0x62,0x65,0x20,0x69,0x74,0x2E
    };
    static const uint8_t expected_cipher[114] = {
        0xD3,0x1A,0x8D,0x34,0x64,0x8E,0x60,0xDB,0x7B,0x86,0xAF,0xBC,
        0x53,0xEF,0x7E,0xC2,0xA4,0xAD,0xED,0x51,0x29,0x6E,0x08,0xFE,
        0xA9,0xE2,0xB5,0xA7,0x36,0xEE,0x62,0xD6,0x3D,0xBE,0xA4,0x5E,
        0x8C,0xA9,0x67,0x12,0x82,0xFA,0xFB,0x69,0xDA,0x92,0x72,0x8B,
        0x1A,0x71,0xDE,0x0A,0x9E,0x06,0x0B,0x29,0x05,0xD6,0xA5,0xB6,
        0x7E,0xCD,0x3B,0x36,0x92,0xDD,0xBD,0x7F,0x2D,0x77,0x8B,0x8C,
        0x98,0x03,0xAE,0xE3,0x28,0x09,0x1B,0x58,0xFA,0xB3,0x24,0xE4,
        0xFA,0xD6,0x75,0x94,0x55,0x85,0x80,0x8B,0x48,0x31,0xD7,0xBC,
        0x3F,0xF4,0xDE,0xF0,0x8E,0x4B,0x7A,0x9D,0xE5,0x76,0xD2,0x65,
        0x86,0xCE,0xC6,0x4B,0x61,0x16
    };
    static const uint8_t expected_tag[16] = {
        0x1A,0xE1,0x0B,0x59,0x4F,0x09,0xE2,0x6A,
        0x7E,0x90,0x2E,0xCB,0xD0,0x60,0x06,0x91
    };

    uint8_t ciphertext[sizeof(plaintext)];
    uint8_t tag[16];
    ttak_crypto_ctx_t ctx = {0};
    ctx.key = key;
    ctx.key_len = sizeof(key);
    ctx.iv_len = sizeof(nonce);
    memcpy(ctx.iv, nonce, sizeof(nonce));
    ctx.aad = aad;
    ctx.aad_len = sizeof(aad);
    ctx.in = plaintext;
    ctx.in_len = sizeof(plaintext);
    ctx.out = ciphertext;
    ctx.out_len = sizeof(ciphertext);
    ctx.tag = tag;
    ctx.tag_len = sizeof(tag);

    ttak_io_status_t rc = ttak_chacha20_poly1305_execute(&ctx, ctx.in, ctx.out, ctx.in_len);
    ASSERT_MSG(rc == TTAK_IO_SUCCESS, "ChaCha20-Poly1305 execution failed (%d)", rc);
    ASSERT(memcmp(ciphertext, expected_cipher, sizeof(ciphertext)) == 0);
    ASSERT(memcmp(tag, expected_tag, sizeof(tag)) == 0);
}

int main(void) {
    RUN_TEST(test_rfc8439_vector);
    return 0;
}
